# _4장 객체와 배열 함수의 기초_

## _4.1 객체의 기초 1) 객체 리터럴_

- 자바스크립트에서는 `원시타입`을 제외한 모든 값이 객체이다.
- `객체`는 자바스크립트에서 가장 중요한 `데이터 타입`이다.



### _4.1.1 객체_

---

***객체?*** 이름과 값을 한 쌍으로 묶은 데이터를 여러 개 모은 것을 의미한다. 즉, 객체는 데이터 여러 개를 하나로 모은 복합 데이터로 **연관 배열** 또는 **사전**이라고 부른다. 

***EX 4.1.1-1) 트럼프 카드를 표현하는 객체*** 

| 이름     | 값         |
| -------- | ---------- |
| **suit** | **"하트"** |
| **rank** | **"A"**    |

- 객체에 포함된 데이터 하나(`이름`과 `값`의 쌍)를 가리켜 ***프로퍼티***라고 부른다.
- `suit`와 `rank`는 프로퍼티이며, 이름 부분을 **프로퍼티 이름** 또는 **키** 라고 부른다.



***EX 4.1.1-2) 자바스크립트에서 객체를 생성하는 방법*** 

1. `객체 리터럴`을 사용
2. `생성자`라는 함수를 사용



### _4.1.2 변수 선언_

---

***EX 4.1.2-1) 트럼프 카드의 정보를 객체 리터럴로 표현*** 

```javascript
var card = {suit:"하트", rank:"A"}; // {suit:"하트", rank:"A"}부분이 바로 객체 리터럴
```

객체리터럴의 변수를 `card`에 대입하고 있다. 

프로퍼티 **이름**과 프로퍼티 **값**은 suit:"하트"처럼 `콜론(:)`을 사용해서 구분하며, `중괄호({})`안에 있는 프로퍼티들은 `쉼표(,)`로 구분한다.

- 프로퍼티 값에는 모든 데이터 타입의 값과 표현식을 대입할 수 있다. 	



변수에 대입된 객체 안의 프로퍼티 값을 읽거나 쓸 때는 `마침표(.)`연산자 또는 `대괄호({})`연산자를 사용한다.

```javascript
card.suit // → 하트
card["rank"] // → A

//객체에 없는 프로퍼티를 읽으려고 시도하면?
card.color // → underfined 

//객체 리터럴 안에 어떠한 프로퍼티도 작성하지 않으면? 
var obj = {}
console.log(obj); // → Object{} 빈 객체가 생성
```



### _4.1.3 프로퍼티 추가와 삭제_

---

***EX 4.1.3-1) 없는 프로퍼티 이름에 값을 대입하면 새로운 프로퍼티가 추가 된다.*** 

```javascript
card.value=14;
console.log(card); // → Object{suit:"하트", rank:"A", value:14}
```



***EX 4.1.3-2) delete 연산다를 사용하면 프로퍼티를 삭제할 수 있다.*** 

```javascript
delete card.rank;
console.log(card); // → Object{suit:"하트", value:14}
```



- Javascript 객체는 실행 중에 프로퍼티를 자유롭게 추가하거나 삭제할 수 있지만, `Java`와 `C++`등에서는 객체의 프로퍼티를 실행 중에 추가하거나 삭제할 수 없다. 



### _4.1.4 in 연산자로 프로퍼티가 있는지 확인하기_

---

`in`연산자를 사용하면 객체에 특정 프로퍼티가 있는지 확인할 수 있다. 프로퍼티가 객체에 포함 여부에 따라서 `true`와 `false`를 반환한다.

```
프로퍼티의 이름을 뜻하는 문자열 in 객체명
```



***EX 4.1.4-1) in연산자 예*** 

```javascript
var card = {suit : "하트", rank:"A"};
console.log("suit" in card); // → true
console.log("color" in card); // → false
```

- `in`연산자가 조사하는 대상이 그 객체가 가진 프로퍼티와 그 객체가 상속받은 모든 프로퍼티라는 점을 주의!

```javascript
console.log("toString" in card); // → true why? card는 Object 객체를 상속받았기 때문
```





### _4.1.5 객체 리터럴 예제_

---

> **1) 좌표평면의 점을 표현하는 객체**

```javascript
var p = {x:1.0, y:2.5};
```



> **2) 원을 표현하는 객체**

```javascript
var circle ={
    center:{x:1.0, y:2.0}, // → 원의 중점을 표현하는 객체
    radius:2.5 // → 원의 반지름
};
```

- `center`프로퍼티는 원의 중점을 표현
- `radius`프로퍼티는 원의 반지름을 표현

```javascript
circle.center.x // → 1.0
```



> **3) 회원 정보를 표현하는 객체**

```javascript
var member ={
    name:"오태권", // 회원 이름
    age:"29", // 회원 나이
    sex:"male", // 성별
    married: false // 결혼여부를 표현하는 논리값
};

member.name // → 오태권
member.age // → 29
member.sex // → male
member.married // → false
```



### _4.1.6 메서드_

---

***메서드란?***  "프로퍼티에 저장된 값의 타입이 함수."를 말한다.



### _4.1.7 객체는 참조타입_

---

생선된 객체는 메모리의 영역을 차지하는 한 덩어리가 된다. 객체 타입의 값을 변수에 대입하면 그 변수에는 객체의 **참조(메모리에서의 위치 정보)**가 저장된다. 이때의 변수 상태를 가리켜 그 객체를 "**참조하고 있다.**"라고 말한다. 

***EX 4.1.7-1) 변수 card는 객체를 참조하고 있다.*** 

<img src="https://user-images.githubusercontent.com/75871005/123676036-606a7300-d87e-11eb-88f6-e9d5dc716440.png" style="zoom:150%;" />

```javascript
var a = card;
console.log(a.suit) // → 하트
a.suit = "스페이드";
console.log(a.suit); // → 스페이드
console.log(card.suit); // → 스페이드
```



![](https://user-images.githubusercontent.com/75871005/123676723-48472380-d87f-11eb-8db4-15c5721e294c.png)

----





## _4.2 함수의 기초_

- `함수`는 자바스크립트 프로그래밍 언어를 규정하는 가장 중요한 구성 요소이다.



### _4.2.1 함수_

---

***EX 4.2.1-1) 수학에서 함수 표현*** 



![](https://user-images.githubusercontent.com/75871005/123677349-f652cd80-d87f-11eb-8a05-cd13df21148c.png)

- 자바스크립트에서 함수는 일련의 처리를 하나로 모아 언제든 호출할 수 있도록 만들어 둔 것.
- 수학 함수와의 차이는 ***입력을 받은 후에 함수 안의 프로그램에서 특정 작업을 수행***
- 함수의 입력 값을 **인수**라고 부르며, 출력 값을 **반환값**이라 부른다.



### _4.2.2 함수 선언문으로 함수 정의하기_

---

함수는 `function` 키워드를 사용해서 정의한다. 

***EX 4.2.2-1) 함수 표현 예*** 

```javascript
function square(x){return x*x;}
```



### 참고📝

```javascript
//return과 값 사이에 줄 바꿈 문자를 넣으면 자바스크립트 엔진이 세미콜론을 자동으로 추가하여 해석한다. 

return
x*x;

// 자바스크립트 엔진에서  이 코드의 해석은

return;
x * x;
// 즉, 값이 없는 return 문으로 해석한다.
```

- return문이 실행되면 제어권이 함수를 호출한 코드로 되돌아가고, return문에 지정된 값(앞, 코드에서는 x*x : x와 x의 곱)은 함수의 반환값이 된다.



### _4.2.3 함수 이름_

---

- 변수와 마찬가지로 모든 식별자를 함수 이름으로 사용할 수 있다. 
- 하지만, 이해하기 쉽게 지어야 `가독성`과 `유지보수성`이 높아 질 수 있다. 





### _4.2.4 함수 호출_

---

- 함수를 호출하려면 함수 이름 뒤에 `소괄호`로 인수를 묶어 입력해야한다.

```javascript
function square(x){return x*x;}
square(3) // 9
```

1. 인수로 넘긴 값인 3이 함수 정의문의 인수 x로 전달.
2. 중괄호 안에 작성된 코드를 실행.
3. return문의 값이 9가 함수의 반환값이 된다.
4. 이때, 함수를 호출할 때 전달하는 값을 **인수(argument)**, 함수 정의문의 인수를 **인자(parameter)**라고 부른다.

![](https://user-images.githubusercontent.com/75871005/123680284-7a5a8480-d883-11eb-9475-dc4abd5d5a87.png)





### _4.2.5 인수_

---

- 함수는 인수를 **여러 개** 받을 수 있다. (여러 개일때, 인수와 인수를 `쉼표(,)`로 구분한다.)

```javascript
function dist(p,q){
    var dx = q.x - p.x;
    var dy = q.y - p.y;
    return Math.sqrt(dx*dx+dy*dy); //Math.sqrt는 제곱근을 구하는 함수
}

var p1 = {x:1, y:1};
var p2 = {x:4, y:5};
var d = dist(p1, p2); // 5


// 인수를 받지 않는 함수도 정의할 수 있다.
var bark = function(){console.log("Hello Javascirt");};
bark(); //"Hello Javascript"
console.log(bark()); // underfined
```



### _4.2.6 함수의 실행 흐름_

---

1. 호출한 코드에 있는 **인수**가 함수 정의문의 인자에 대입된다.
2. 함수 정의문의 **중괄호** 안에 작성된 프로그램이 **순차적**으로 실행된다.
3. **return**문이 실행되면 호출한 코드로 돌아간다.
   - **return**문의 값이 함수의 `반환값`이 된다.
4. **return**문이 실행되지 않은 상태로 마지막 문장이 실행되면, 호출한 코드로 돌아간 후에 **underfined**가 함수의 반환값이 된다.





### _4.2.7 함수 선언문의 끌어올림_

---

- 자바스크립트 엔진은 변수 선언문과 마찬가지로 **함수 선언문**을 프로그램의 첫 머리로 끌어올린다. 
- **함수 선언문**은 프로그램의 어떤 위치에도 작성이 가능.

```javascript
console.log(square(5)); // 25
function square(x){return x*x};
```



### _4.2.8 값으로서의 함수_

---

- 자바스크립트에서 함수는 객체이다.
- **함수 선언문**으로 함수를 선언하면 내부적으로 그 함수 이름을 변수 이름으로 한 변수와 함수객체가 만들어진다.
- 그 변수에 함수 객체의 참조가 저장.





### _4.2.9 참조에 의한 호출과 값에 의한 호출_

---

- 함수는 원시 값을 넘겼을 때와 객체를 인수로 넘겼을 때 다르게 동작한다.

```javascript
function add1(x) {return x = x+1;}
var a = 3;
var b = add1(a);
console.log("a = " + a + ", b = " + b); // → a=3 , b=4
// add1 은 전달받은 인수에 1을 더하여 반환하는 함수
// 즉, 인수에 원시 값을 넘기면 그 값 자체가 인자에 전달된다. 이를 '값의 전달'이라 부른다.
```



### _4.2.10 변수의 유효 범위_

---

> **1) 전역 유효 범위와 지역 유효 범위**

- 유효범위(scope) : 변수에 접근할 수 있는 범위.

  - 어휘적 범위 : 프로그램 구문만으로 유효 범위를 정함.
  - 동적 범위 : 프로그램 실행 중에 유효 범위를 정함.
    - `c`,`Java` 
    - `Javascript`
      - **전역 변수**
        - 함수 바깥에서 선언된 변수로 유효 범위가 전체 프로그램
      - **지역 변수**
        - 함수 안에서 선언된 변수와 함수 인자로 유효 범위는 변수가 함수 내부

  

  ```javascript
  var a = "global";
  function f(){
      var b ="local";
      console.log(a); // "gobal"
      return b;
  }
  f();
  console.log(b); // ReferenceError : b is not defined
  ```

  - `var a`는 전역 변수 : 범위는 전체 프로그램
  -  `var b`는 지역 변수 : 함수 f 안에서만 유효함

  

  > **2. 변수의 충돌**

  - ***변수에 유효범위가 있는 이유는?***  충돌하지 않도로 하기 위함
  - 전역변수 이름과 지역 변수 이름이 같아지면 충돌하게 된다.

  ***EX)***

  ```javascript
  var a = "gobal";
  function f(){
      var a = "local";
      console.log(a); // local
      return a;
  }
  f();
  console.log(a); // global
  ```

  

  > **3. 함수 안에서의 변수 선언과 변수 끌어올림**

  - 함수 안에서 선언된 지역 변수의 유효 범위는 `함수 전체`이다.

  ```javascript
  function f(){
      console.log(a); // underfined
      var a = "local";
      console.log(a); // local
      retrun a; 
  }
  ```

  

  > **4. 함수 안에서의 변수 선언 생략**

  - 변수를 선언하지 않은 상태에서 값을 대입하면 전역 변수로 선언된다.

  ```javascript
  function f(){
      a="local";
      console.log(a); // local
      return a;
  }
  f();
  console.log(a); // local
  ```

  `var`로 선언하지 않았으므로 **전역변수**이다.



### _4.2.11 블록 유효 범위 : let 과 const_

---

`let`과 `const`는 ECMAScript6 부터 추가된 `변수 선언자`로 모두가 **'불록 유효 범위'**를 갖는 변수를 선언한다.

- 블록 유효 범위를 가진 변수는 중괄호`({})`안에서만 유효하다
- let : 변수를 선언
- const : 한 번만 할당할 수 있는 상수를 선언



> **1. let 선언자**

- `let`문은 불록 유효 범위를 갖는 지역변수를 선언한다. 사용법은 `var`과 같다.

```javascript
let x;

let a, b, c; // 변수가 여러 개일때 쉼표로 구분하여 동시에 선언할 수 있다.

let x = 5, y = 7; // 변수를 선언하면서 초깃값을 설정할 수 도 있다.
```



#### var 과 let의 차이

- let으로 선언한 변수의 유효 범위가 불록 안이라는 점

```javascript
let x ="outer x";										//바깥쪽 x의 유효범위
{
    let x = "inner x";				//안쪽 x,y의 유효범위
    let y = "inner y";				//안쪽 x,y의 유효범위
    console.log(x); // inner x		//안쪽 x,y의 유효범위
    console.log(y); // inner y		//안쪽 x,y의 유효범위
}
console.log(x); // outer x
console.log(y) // ReferenceError: y is not defined		//바깥쪽 x의 유효범위
```



> **2. const 선언자**

- `const` 문은 블록 유효 범위를 가지면서 한 번만 할당할 수 있는 변수(상수)를 선언한다.
- `const`로 선언한 상수는 `let`문으로 선언한 변수처럼 동작하지만, ***반드시 초기화해야한다.***

```javascript
const c = 2;

c = 5; // Uncaught TypeError

//const 문으로 선언한 변수에 다시 대입하면 타입 오류가 발생한다.
```

- `const`문으로 선언한 상수 값은 수정할 수 없지만, 상수 값이 `객체`이거나 `배열`일 경우에는 프로퍼티 또는 프로퍼티 값을 수정할 수 있다.

```javascript
const origin = {x:1, y:2};
origin.x = 3;
console.log(origin); //Object{x:3 y:2}
```



### _4.2.12 함수 리터럴로 함수 정의하기_

---

- 함수는 함수 리터럴로도 정의할 수 있다.

```javascript
var square = function(x){return x*x;};
// function(x){....} 부분이 함수 리터럴이다.
```

- **함수 리터럴**은 이름이 없는 함수이므로 **익명 함수** 또는 **무명 함수**이다.

  

### _4.2.13 객체의 메서드_

---

- 메서드 : 객체의 프로퍼티 중에서 함수 객체의 참조를 값으로 담고 있는 프로퍼티

```javascript
var circle = {
    center {x:1.0, y:2.0}, //원의 중점을 표현하는 객체
    radius: 2.5,
    area:function(){
        retrun Math.PI*this.radius*this.radius;
    } // 함수 객체 안의 this는 그 함수를 메서드로 가지고 있는 객체를 의미한다.
};//즉, this.radius가 circle.radius이다.
```

- 메서드는 일반저긍로 메서드가 속한 객체의 내부 데이터(프로퍼티 값) 상태로 바꾸는 용도로 사용한다. 
- 일반적인 객체 지향 언어에서는 데이터와 그 상태를 바꾸는 메서드를 하나로 묶는 용도로 객체를 사용한다.

#### 메서드는 프로퍼티

```
C++나 JAVA 등의 객체 지향 언어에서는 객체 안의 데이터와 메서드를 별개로 다룬다. 하지만, 자바스크립트의 메서드는 함수를 값으로 가진 프로퍼티이다.
```



### _4.2.14 함수를 활용하면 얻을 수 있는 장점_

---

- 재사용할 수 있다.
- 만든 프로그램을 이해하기 쉽다.
- 프로그램 수정이 간단해진다.

![](https://user-images.githubusercontent.com/75871005/123974053-456f3e80-d9f7-11eb-897e-1a627b6859b3.png)